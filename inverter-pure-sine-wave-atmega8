	#define F_CPU 12000000UL

	#include <stdlib.h>

    #include <avr/io.h>

    #include <util/delay.h>

    #include <avr/interrupt.h>

    #include <avr/sleep.h>

    #include <math.h>

    #include <stdio.h>

	int i=0;

	static volatile unsigned char wave[257];

	static volatile unsigned char sample = 0;

// http://www.theengineeringprojects.com/2012/11/pure-sine-wave-inter-design-with-code.html
// that program is for ATmega16
// made this program for ATmega8 - did not test if it works on an ATmega8 yet, it just compiles well

/*
    0x80, 0x83, 0x86, 0x89, 0x8C, 0x90, 0x93, 0x96,

    0x99, 0x9C, 0x9F, 0xA2, 0xA5, 0xA8, 0xAB, 0xAE,

    0xB1, 0xB3, 0xB6, 0xB9, 0xBC, 0xBF, 0xC1, 0xC4,

    0xC7, 0xC9, 0xCC, 0xCE, 0xD1, 0xD3, 0xD5, 0xD8,

    0xDA, 0xDC, 0xDE, 0xE0, 0xE2, 0xE4, 0xE6, 0xE8,

    0xEA, 0xEB, 0xED, 0xEF, 0xF0, 0xF1, 0xF3, 0xF4,

    0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFA, 0xFB, 0xFC,

    0xFD, 0xFD, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF,

    0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFD,

    0xFD, 0xFC, 0xFB, 0xFA, 0xFA, 0xF9, 0xF8, 0xF6,

    0xF5, 0xF4, 0xF3, 0xF1, 0xF0, 0xEF, 0xED, 0xEB,

    0xEA, 0xE8, 0xE6, 0xE4, 0xE2, 0xE0, 0xDE, 0xDC,

    0xDA, 0xD8, 0xD5, 0xD3, 0xD1, 0xCE, 0xCC, 0xC9,

    0xC7, 0xC4, 0xC1, 0xBF, 0xBC, 0xB9, 0xB6, 0xB3,

    0xB1, 0xAE, 0xAB, 0xA8, 0xA5, 0xA2, 0x9F, 0x9C,

    0x99, 0x96, 0x93, 0x90, 0x8C, 0x89, 0x86, 0x83,

    0x80, 0x7D, 0x7A, 0x77, 0x74, 0x70, 0x6D, 0x6A,

    0x67, 0x64, 0x61, 0x5E, 0x5B, 0x58, 0x55, 0x52,

    0x4F, 0x4D, 0x4A, 0x47, 0x44, 0x41, 0x3F, 0x3C,

    0x39, 0x37, 0x34, 0x32, 0x2F, 0x2D, 0x2B, 0x28,

    0x26, 0x24, 0x22, 0x20, 0x1E, 0x1C, 0x1A, 0x18,

    0x16, 0x15, 0x13, 0x11, 0x10, 0x0F, 0x0D, 0x0C,

    0x0B, 0x0A, 0x08, 0x07, 0x06, 0x06, 0x05, 0x04,

    0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03,

    0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x0A,

    0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x13, 0x15,

    0x16, 0x18, 0x1A, 0x1C, 0x1E, 0x20, 0x22, 0x24,

    0x26, 0x28, 0x2B, 0x2D, 0x2F, 0x32, 0x34, 0x37,

    0x39, 0x3C, 0x3F, 0x41, 0x44, 0x47, 0x4A, 0x4D,

    0x4F, 0x52, 0x55, 0x58, 0x5B, 0x5E, 0x61, 0x64,

    0x67, 0x6A, 0x6D, 0x70, 0x74, 0x77, 0x7A, 0x7D

*/

    void InitSinTable()

    {

    //Page | 42

    //sin period is 2*Pi

    const float step = (2*M_PI)/(float)256;

    float s;

    float zero = 128.0;

    //in radians

    for(i=0;i<256;i++)

    {

    s = sin( i * step );

    //calculate OCR value (in range 0-255, timer0 is 8 bit)

    wave[i] = (uint8_t) round(zero + (s*127.0));

    }

    }

    void InitPWM()

    {

    /*

    TCCR0 - Timer Counter Control Register (TIMER0)

    -----------------------------------------------

    BITS DESCRIPTION

    NO: NAME DESCRIPTION

    --------------------------

    BIT 7 : FOC0 Force Output Compare

    BIT 6: WGM00 Wave form generartion mode [SET to 1]

    BIT 5: COM01 Compare Output Mode [SET to 1]

    BIT 4: COM00 Compare Output Mode [SET to 0]

    BIT 3: WGM01 Wave form generation mode [SET to 1]

    BIT 2: CS02 Clock Select [SET to 0]

    BIT 1: CS01 Clock Select [SET to 0]

    BIT 0: CS00 Clock Select [SET to 1]

    Timer Clock = CPU Clock (No Pre-scaling)

    Mode = Fast PWM

    PWM Output = Non Inverted

    */

    TCCR0|=(1<<WGM12)|(1<<WGM10)|(1<<COM21)|(1<<CS00);

    TIMSK|=(1<<TOIE0);

    //Set OC0 PIN as output. It is PB3 on ATmega16 ATmega32
	//Timer/Counter0 Output Compare Match Output
	// On ATmega8 it is called OC1A and it is on PB1, on USBasp it is also connected to PD2(INT0) and through a 68 ohm and 3v6 zener to usb d+

    DDRB|=(1<<PB1);

    }

int main(void) {


// Wait for power stabilisation
_delay_ms(500);
InitSinTable();
InitPWM();
sei(); // // activate interrupts so (TIMER0_OVF_vect) is available
while(1)
{
_delay_ms(100);  // test done in interrupt, main just does nothing
}


}

    ISR(TIMER0_OVF_vect)

    {

    OCR1A = wave[sample];

    sample++;

    if( sample >= 255 )

    sample = 0;

    }
    
    
