#define F_CPU 12000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdio.h>		// sprintf()
//#include <stdlib.h>	// itoa()
//#include <math.h>		// sin cos tg ctg
#include "lcdcontrolusbasp.h"

// (F)recuency of (note) (normal / plus a semitone) (scale A B C D E F)
// https://en.wikipedia.org/wiki/Scale_(music)
// https://en.wikipedia.org/wiki/Musical_note
//  # note = plus a semitone
//  b note = minus a semitone
// C MAJOR SCALE = SCALE C HERE = STARTS FROM ONE LINE UNDER THE SCORE AND ENDS AT MIDDLE OF SCORE
// C MAJOR SCALE HAS IN THE MIDDLE OF IT THE SOL KEY START POINT AT THE SOL NOTE, ON LINE 2
// THE NEXT DO FOR D SCALE IS BETWEEN LINE 3 AND LINE 4
//
// ASCII ART REPRESENTATION OF SCALES C AND D HERE WITH THEIR NOTES:
//
//																			FSIND
//																	---FLAND---
//																 FSOLND
//----------------------------------------------------------FFAND------------------
//													   FMIND						SCALE D AREA (OPTIMUM FOR BUZZER)
//------------------------------------------------FREND----------------------------
//											 FDOND
//--------------------------------------FSINC--------------------------------------
//								   FLANC
//--SOL-KEY-START------------FSOLNC------------------------------------------------
//						FFANC														SCALE C AREA (OPTIMUM FOR SPEAKER)
//-----------------FMINC-----------------------------------------------------------
//			  FRENC
//    ---FDONC---

#define FDONA	131
#define FDOSA	139
#define FRENA	147
#define FRESA	156
#define FMINA	165
#define FFANA	175
#define FFASA	185
#define FSOLNA	196
#define FSOLSA	208
#define FLANA	220
#define FLASA	233
#define FSINA	247
#define FDONB	262
#define FDOSB	277
#define FRENB	294
#define FRESB	311
#define FMINB	330
#define FFANB	349
#define FFASB	370
#define FSOLNB	392
#define FSOLSB	415
#define FLANB	440
#define FLASB	466
#define FSINB	494
#define FDONC	523
#define FDOSC	554
#define FRENC	587
#define FRESC	622
#define FMINC	659
#define FFANC	698
#define FFASC	740
#define FSOLNC	784
#define FSOLSC	831
#define FLANC	880
#define FLASC	932
#define FSINC	988
#define FDOND	1047
#define FDOSD	1109
#define FREND	1175
#define FRESD	1245
#define FMIND	1319
#define FFAND	1397
#define FFASD	1480
#define FSOLND	1568
#define FSOLSD	1661
#define FLAND	1760
#define FLASD	1865
#define FSIND	1976
#define FDONE	2093
#define FDOSE	2217
#define FRENE	2349
#define FRESE	2489
#define FMINE	2637
#define FFANE	2794
#define FFASE	2960
#define FSOLNE	3136
#define FSOLSE	3322
#define FLANE	3520
#define FLASE	3729
#define FSINE	3951
#define FDONF	4186
#define FDOSF	4435
#define FRENF	4699
#define FRESF	4978
#define FMINF	5274
#define FFANF	5588
#define FFASF	5920
#define FSOLNF	6272
#define FSOLSF	6645
#define FLANF	7040
#define FLASF	7459
#define FSINF	7902


//Prototypes ( functions declared at beginning so they are always found later - no errors )
void setup();
void LCD_update_time();
void LCD_update_timesel();
void var_delay_us(uint16_t);
void makesnd(uint16_t, uint8_t);	// FREQUENCY, DURATION


/*Global Variables Declarations*/
unsigned int adc_value;
unsigned char hours = 0;
unsigned char minutes = 0;
unsigned char seconds = 0;
//char time[] = "00:00:00";
 
unsigned char hourssel = 0;
unsigned char minutessel = 0;
unsigned char secondssel = 0; // si zero ramane mereu
//char timesel[] = "00:00:00";
char lcdint [3];                           	// only 2 characters + not specified null to use integer to int, for lcd

	static volatile unsigned char iiii = 0x01; //	1=ignored by compiler; 2: hours;  3: minutes; 4: day; 5: month; 6: year;
//	int was_selected = 0, was_pressed = 0;
//	int waiting_to_reset = 0;

void setup() {
// Wait for power stabilization
  _delay_ms(100); 

// ENABLE PORTS

	// Variable to hold ADC result
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	// Set ADCSRA Register with division factor 128
	ADMUX = (1<<REFS0) | (1<<ADLAR) | (1<<MUX1);

//((1<<pin)|(1<<pin)|(1<<pin));

  DDRB |= (1<<0); // BUZZER
  PORTB &= ~ (1<<0);
  DDRC |= (1<<0); //LED1
  PORTC &= ~ (1<<0);

// c) registrul unde vede input se citeste in functii

  lcdini();

}

int main(void) {


	setup();
	gotolcdlocation(1,1);
	lcdputs("                ");
	gotolcdlocation(1,2);

	lcdputs("                ");
	_delay_ms(100);

	TCCR1B |= (1<<WGM12); // clear timer on compare (when OCR1A is reached, automatically go to 0)

//  Also check #define F_CPU clocks
//	OCR1A = 15625; // 1 second on 16mhz with prescaler 1024 => 	TCCR1B |= (1<<CS12) | (1<<CS10);
	OCR1A = 46875; // 1 second on 12mhz with prescaler 256  =>  TCCR1B |= (1<<CS12);

	TIMSK |= (1<<OCIE1A); // when OCR1A is reached, go to ISR(TIMER1_COMPA_vect) interrupt


	GICR &= ~(1 << INT0); // usbasp has a usb data pin on interrupt, don't want interrupt on button low
	sei(); // activate interrupts so (TIMER1_COMPA_vect) is available
	GICR &= ~(1 << INT0); // SEI ENABLES IT I THINK
	// And now that interrupt INT0 is disabled, setting as ignored input with pull up so that button PB1 helped
	DDRD &= ~ (1 << 2);
	PORTD |= (1 << 2);

// protect the real button that does not work because of resistor in main()
	DDRB &= ~ (1<<1); // input
	PORTB &= ~ (1<<1); // no pull up

//	TCCR1B |= (1<<CS12) | (1<<CS10); // setting prescaler also starts the counting of the timer, for 16MHz
	TCCR1B |= (1<<CS12);			// setting prescaler also starts the counting of the timer, for 12Mhz

//  Avoid using REGISTER = (1<<BIT); that makes previous settings zero (like WGM12 for example)
//  better always use for 1: REGISTER |= (1<<BIT);
//  better always use for 0: REGISTER &= ~ (1<<BIT);

// do, re, mi, fa, sol, la, si, do, do, si, la, sol, fa, mi, re, do
					makesnd(FDOND,2);
					makesnd(FREND,2);
					makesnd(FMIND,2);
					makesnd(FFAND,2);
					makesnd(FSOLND,2);
					makesnd(FLAND,2);
					makesnd(FSIND,2);
					makesnd(FDONE,2);
					_delay_ms(250);
					makesnd(FDONE,2);
					makesnd(FSIND,2);
					makesnd(FLAND,2);
					makesnd(FSOLND,2);
					makesnd(FFAND,2);
					makesnd(FMIND,2);
					makesnd(FREND,2);
					makesnd(FDOND,2);
					_delay_ms(250);

	adc_value = 0; 
	ADCSRA |= (1<<ADSC); //Forever since it is in single conversion mode
	// Start conversion for the first time
	while(1)
    	{

			LCD_update_time();
			LCD_update_timesel();	

			if (!(ADCSRA & (1<<ADSC))) // detect that ADSC is 0 and then do what is in the accolades
			{
				// wait until conversion completes; ADSC=0 means Complete
				adc_value = ADCH;
				//Store ADC result
				ADCSRA |= (1<<ADSC); //Forever since it is in single conversion mode
				// Start conversion in loop
			}

		_delay_ms(50);

	} // acolada de la while(1)

	return 0;
}


void LCD_update_time() {

	gotolcdlocation(1,1);
	lcdputs("  "); // empty selected field
	sprintf(lcdint, "%02d", hours);
	lcdputs(lcdint);
	lcdputs(" : ");
 	sprintf(lcdint, "%02d", minutes);
	lcdputs(lcdint);
	lcdputs(" : ");
	sprintf(lcdint, "%02d", seconds);
	lcdputs(lcdint);
	lcdputs("  "); // sometimes errors appear at the end
}

void LCD_update_timesel() {
	gotolcdlocation(1,2); // (coloana, rand)
	lcdputs("      "); // "      xxx"
	sprintf(lcdint, "%03d", adc_value); // lcdint is just a char array just made by sprintf
	lcdputs(lcdint);	// display the lcdint char array
	lcdputs("       ");  // sometimes errors appear at the end
}

void var_delay_us(uint16_t usvar)	// allow delays without constant, for buzzer
{
	// =1/7902/5 resolution 5 times bigger than highest frequency 7902 => 0.00002531005 s ~= 25 us + 1 clock calcul usvar--
	// not smaller than 10 us because UC instruction times interference will make the time unit incorrect
  while (usvar-- != 0)
    _delay_us(25);	
}

void makesnd(uint16_t frequency, uint8_t duration)	// duration represented as 16 for one second, linear
{
//		frequency=frequency/2;	// this is int, all fractions are lost
		uint16_t sinusoidrepetition = 0;	// number of sinusoids
		uint16_t sinusoidtime = 0;			// length of time for a sinusoid
//		tempo is usually 120 beats per minute - half a second, number written down 2/2=half second 4/4=quarter second
//		https://en.wikipedia.org/wiki/Tempo
		uint8_t tempo = 2; // the bigger, the shorter the note at the same frequency (parts of a second)
		sinusoidrepetition = duration*frequency/tempo/16;
		sinusoidtime=1000000/25/frequency;	// 25 us is the var_delay_us time unit, 1000000 us is one second
		sinusoidtime=sinusoidtime/2; // one pulse is composed of an up and a down, time used is half
   		while(sinusoidrepetition){
			var_delay_us(sinusoidtime);	// buzzer frequency
			PORTB |= (1<<0);
			var_delay_us(sinusoidtime);	// buzzer frequency
			PORTB &=~ (1<<0);
    	 	sinusoidrepetition--;
		}
//		_delay_ms(25);
}

/*Timer Counter 1 Compare Match A Interrupt Service Routine/Interrupt Handler*/
ISR(TIMER1_COMPA_vect)
{
	PORTC &= ~ (1<<0); //LED1 tic	
	_delay_ms(5);
	PORTC |= (1<<0); //LED1 tac	
	seconds++;

	if(seconds == 60)
	{
		seconds = 0;
		minutes++;
	}
	if(minutes == 60)
	{
		minutes = 0;
		hours++;		
	}
	if(hours > 23) {
		hours = 0;
	}
	
}
