#define F_CPU 12000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdio.h>		// sprintf()
//#include <stdlib.h>	// itoa()
//#include <math.h>		// sin cos tg ctg
#include "lcdcontrolusbasp.h"

// (F)recuency of (note) (normal / plus a semitone) (scale A B C D E F)
// https://en.wikipedia.org/wiki/Scale_(music)
// https://en.wikipedia.org/wiki/Musical_note
//  # note = plus a semitone
//  b note = minus a semitone
// C MAJOR SCALE = SCALE C HERE = STARTS FROM ONE LINE UNDER THE SCORE AND ENDS AT MIDDLE OF SCORE
// C MAJOR SCALE HAS IN THE MIDDLE OF IT THE SOL KEY START POINT AT THE SOL NOTE, ON LINE 2
// THE NEXT DO FOR D SCALE IS BETWEEN LINE 3 AND LINE 4
//
// ASCII ART REPRESENTATION OF SCALES C AND D HERE WITH THEIR NOTES:
//
//																			FSIND
//																	---FLAND---
//																 FSOLND
//----------------------------------------------------------FFAND------------------
//													   FMIND						SCALE D AREA (OPTIMUM FOR BUZZER)
//------------------------------------------------FREND----------------------------
//											 FDOND
//--------------------------------------FSINC--------------------------------------
//								   FLANC
//--SOL-KEY-START------------FSOLNC------------------------------------------------
//						FFANC														SCALE C AREA (OPTIMUM FOR SPEAKER)
//-----------------FMINC-----------------------------------------------------------
//			  FRENC
//    ---FDONC---

#define FDONA	131
#define FDOSA	139
#define FRENA	147
#define FRESA	156
#define FMINA	165
#define FFANA	175
#define FFASA	185
#define FSOLNA	196
#define FSOLSA	208
#define FLANA	220
#define FLASA	233
#define FSINA	247
#define FDONB	262
#define FDOSB	277
#define FRENB	294
#define FRESB	311
#define FMINB	330
#define FFANB	349
#define FFASB	370
#define FSOLNB	392
#define FSOLSB	415
#define FLANB	440
#define FLASB	466
#define FSINB	494
#define FDONC	523
#define FDOSC	554
#define FRENC	587
#define FRESC	622
#define FMINC	659
#define FFANC	698
#define FFASC	740
#define FSOLNC	784
#define FSOLSC	831
#define FLANC	880
#define FLASC	932
#define FSINC	988
#define FDOND	1047
#define FDOSD	1109
#define FREND	1175
#define FRESD	1245
#define FMIND	1319
#define FFAND	1397
#define FFASD	1480
#define FSOLND	1568
#define FSOLSD	1661
#define FLAND	1760
#define FLASD	1865
#define FSIND	1976
#define FDONE	2093
#define FDOSE	2217
#define FRENE	2349
#define FRESE	2489
#define FMINE	2637
#define FFANE	2794
#define FFASE	2960
#define FSOLNE	3136
#define FSOLSE	3322
#define FLANE	3520
#define FLASE	3729
#define FSINE	3951
#define FDONF	4186
#define FDOSF	4435
#define FRENF	4699
#define FRESF	4978
#define FMINF	5274
#define FFANF	5588
#define FFASF	5920
#define FSOLNF	6272
#define FSOLSF	6645
#define FLANF	7040
#define FLASF	7459
#define FSINF	7902


//Prototypes ( functions declared at beginning so they are always found later - no errors )
void setup();
void LCD_update_time();
void LCD_update_timesel();
void var_delay_us(uint16_t);
void makesnd(uint16_t, uint8_t);	// FREQUENCY, DURATION
void alarmmusic();
void findouttimeminutessel();

// using static volatile keeps in RAM, not in registers, survives interrupts but is slower, good for one second operations and selections
/*Global Variables Declarations*/

static volatile unsigned char hours = 0;
static volatile unsigned char minutes = 0;
static volatile unsigned char seconds = 0;
static volatile uint16_t timeinminutes = 0; //used for alarm decision, in minutes, more than 256 so 16 bit
 
static volatile unsigned char hourssel = 0;
static volatile unsigned char minutessel = 0;
static volatile unsigned char secondssel = 0; // and zero always for the selected second
static volatile uint16_t timeinminutessel = 1; //used for alarm decision, in minutes, more than 256 so 16 bit, bigger than timeinminutes

static volatile unsigned char iiii = 0x01; //	1=ignored by compiler; 2: hours;  3: minutes; 4: day; 5: month; 6: year;
static volatile unsigned char quarterofalarm=0; // for one second what part of the alarm 1,2,3,4 with 4 musical notes each part
//	int was_selected = 0, was_pressed = 0;
//	int waiting_to_reset = 0;

/////////// From here variables don't need to survive interrupt

unsigned int notjuststarted = 0; // 0 = just started (no feedback for selectionpiece) 1 = not just started
unsigned int adc_value = 0; // 0 to 255
unsigned int selectionpiece = 0; // 0 to 64, a quarter of adc_value, selected with some kind of feedback
unsigned int oldselectionpiece = 0; // 0 to 64, a quarter of adc_value, selected with some kind of feedback, older value
char lcdint [3];                           	// only 2 characters + not specified null to use integer to int, for lcd

int main(void) {

	_delay_ms(50); // bedore jumping functions allow small time to make sure microcontroller power is stabilised (increased to 5V)
	setup();
	gotolcdlocation(1,1);
	lcdputs("                ");
	gotolcdlocation(1,2);

	lcdputs("                ");
	_delay_ms(10);

	TCCR1B |= (1<<WGM12); // clear timer on compare (when OCR1A is reached, automatically go to 0)

//  Also check #define F_CPU clocks
//	OCR1A = 15625; // 1 second on 16mhz with prescaler 1024 => 	TCCR1B |= (1<<CS12) | (1<<CS10);
	OCR1A = 46875; // 1 second on 12mhz with prescaler 256  =>  TCCR1B |= (1<<CS12);

	TIMSK |= (1<<OCIE1A); // when OCR1A is reached, go to ISR(TIMER1_COMPA_vect) interrupt


	GICR &= ~(1 << INT0); // usbasp has a usb data pin on interrupt, don't want interrupt on button low
	sei(); // activate interrupts so (TIMER1_COMPA_vect) is available
	GICR &= ~(1 << INT0); // SEI ENABLES IT I THINK
	// And now that interrupt INT0 is disabled, setting as ignored input with pull up so that button PB1 helped
	DDRD &= ~ (1 << 2);
	PORTD |= (1 << 2);

// protect the real button that does not work because of resistor in main()
	DDRB &= ~ (1<<1); // input
	PORTB &= ~ (1<<1); // no pull up

//	TCCR1B |= (1<<CS12) | (1<<CS10); // setting prescaler also starts the counting of the timer, for 16MHz
	TCCR1B |= (1<<CS12);			// setting prescaler also starts the counting of the timer, for 12Mhz

//  Avoid using REGISTER = (1<<BIT); that makes previous settings zero (like WGM12 for example)
//  better always use for 1: REGISTER |= (1<<BIT);
//  better always use for 0: REGISTER &= ~ (1<<BIT);

// do, re, mi, fa, sol, la, si, do, do, si, la, sol, fa, mi, re, do

	adc_value = 0; 
	ADCSRA |= (1<<ADSC); //Forever since it is in single conversion mode
	// Start conversion for the first time
	while(1)
    	{

			LCD_update_time();
			LCD_update_timesel();	

			if (!(ADCSRA & (1<<ADSC))) // detect that ADSC is 0 and then do what is in the accolades
			{
				// wait until conversion completes; ADSC=0 means Complete
				adc_value = ADCH;
				//Store ADC result
				ADCSRA |= (1<<ADSC); //Forever since it is in single conversion mode
				// Start conversion in loop
			}
		findouttimeminutessel();
		_delay_ms(50);

	} // acolada de la while(1)

	return 0;
}

void setup() {
// Initialise LCD
lcdini();

// ENABLE PORTS

	// Variable to hold ADC result
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
	// Set ADCSRA Register with division factor 128
	ADMUX = (1<<REFS0) | (1<<ADLAR) | (1<<MUX1);

//((1<<pin)|(1<<pin)|(1<<pin));

  DDRB |= (1<<0); // BUZZER
  PORTB &= ~ (1<<0);
  DDRC |= (1<<0); //LED1
  PORTC &= ~ (1<<0);


}


void LCD_update_time() {
	gotolcdlocation(1,1);
	lcdputs("  "); // empty selected field
	sprintf(lcdint, "%02d", hours);
	lcdputs(lcdint);
	lcdputs(" : ");
 	sprintf(lcdint, "%02d", minutes);
	lcdputs(lcdint);
	lcdputs(" : ");
	sprintf(lcdint, "%02d", seconds);
	lcdputs(lcdint);
	lcdputs("  "); // sometimes errors appear at the end
}

void LCD_update_timesel() {
	gotolcdlocation(1,2);
	lcdputs("  "); // empty selected field
	sprintf(lcdint, "%02d", hourssel);
	lcdputs(lcdint);
	lcdputs(" : ");
 	sprintf(lcdint, "%02d", minutessel);
	lcdputs(lcdint);
	lcdputs(" : ");
	sprintf(lcdint, "%02d", secondssel);
	lcdputs(lcdint);
	lcdputs("  "); // sometimes errors appear at the end
}

void var_delay_us(uint16_t usvar)	// allow delays without constant, for buzzer
{
	// =1/7902/5 resolution 5 times bigger than highest frequency 7902 => 0.00002531005 s ~= 25 us + 1 clock calcul usvar--
	// not smaller than 10 us because UC instruction times interference will make the time unit incorrect
  while (usvar-- != 0)
    _delay_us(25);	
}

void makesnd(uint16_t frequency, uint8_t duration)	// duration represented as 16 for one second, linear
{
//		frequency=frequency/2;	// this is int, all fractions are lost
		uint16_t sinusoidrepetition = 0;	// number of sinusoids
		uint16_t sinusoidtime = 0;			// length of time for a sinusoid
//		tempo is usually 120 beats per minute - half a second, number written down 2/2=half second 4/4=quarter second
//		https://en.wikipedia.org/wiki/Tempo
		uint8_t tempo = 2; // the bigger, the shorter the note at the same frequency (parts of a second)
		sinusoidrepetition = duration*frequency/tempo/16;
		sinusoidtime=1000000/25/frequency;	// 25 us is the var_delay_us time unit, 1000000 us is one second
		sinusoidtime=sinusoidtime/2; // one pulse is composed of an up and a down, time used is half
   		while(sinusoidrepetition){
			var_delay_us(sinusoidtime);	// buzzer frequency
			PORTB |= (1<<0);
			var_delay_us(sinusoidtime);	// buzzer frequency
			PORTB &=~ (1<<0);
    	 	sinusoidrepetition--;
		}
//		_delay_ms(25);
}

void alarmmusic() {
	switch (quarterofalarm) {
		case 1:
					makesnd(FDOND,4);
					makesnd(FREND,4);
					makesnd(FMIND,4);
					makesnd(FFAND,3); // 4+4+4+3 = 12 not 16 is less than a second, finish before next interrupt
		break;
		case 2:
					makesnd(FSOLND,4);
					makesnd(FLAND,4);
					makesnd(FSIND,4);
					makesnd(FDONE,3); // 4+4+4+3 = 12 not 16 is less than a second, finish before next interrupt
		break;
		case 3:
					makesnd(FDONE,4);
					makesnd(FSIND,4);
					makesnd(FLAND,4);
					makesnd(FSOLND,3); // 4+4+4+3 = 12 not 16 is less than a second, finish before next interrupt
		break;
		case 4:
					makesnd(FFAND,4);
					makesnd(FMIND,4);
					makesnd(FREND,4);
					makesnd(FDOND,3); // 4+4+4+3 = 12 not 16 is less than a second, finish before next interrupt
		break;
		default:
		//code
		break;
	} // accolade for switch (quarterofalarm)
		quarterofalarm++; // this code is always done, not only if no case happened
		if(quarterofalarm>4) quarterofalarm=1;
		// and so this second make no sounds, order for seconds is silence,case1,case2,case3,case4,silence,case1,case2,case3,case4,silence...
}

void findouttimeminutessel() {
// http://www.robotplatform.com/howto/blinker/blinker_6.html
// http://www.avrfreaks.net/forum/tut-c-bit-manipulation-aka-programming-101?page=all
// http://efundies.com/avr-bitwise-operations-in-c/
// https://download.mikroe.com/documents/compilers/mikroc/pic/help/logical_operators.htm

// Hack to see if last two bits of adc value are 1 or 2 or bitwise 01 or 10, required for some kind of feedback 0 [1 2] 3 4 [5 6] 7 8 [9 10] 11...
if( ( ( (!(adc_value &(1<<0))) && (adc_value &(1<<1)) ) || ( (adc_value &(1<<0)) && (!(adc_value &(1<<1))) ) ) || (notjuststarted==0) )
	// if first two bits of adc_value are 01 or 10
	{
	// when adc was mooved with feedback reset counter so that time is measured after not mooving it
	selectionpiece=(adc_value>>2);
	if(notjuststarted==0) oldselectionpiece=selectionpiece+1;
	if(selectionpiece!=oldselectionpiece) // http://www.cprogramming.com/tutorial/c/lesson2.html
		{
		oldselectionpiece=selectionpiece; // make old one equal first of all so that we don't reset time on every pass
		notjuststarted=1;	// no problem if repeated, it only happens when mooving adc
		quarterofalarm=0;	// start alarm from the beginning next time
		seconds = 0;
		minutes = 0;
		hours = 0;
		makesnd(FDOND,1); // aknowledge with short sound that there is a new selection
		// http://www.avrfreaks.net/forum/if-if-if-vs-if-else-if-else-if
		if (selectionpiece<30) // one piece is a minute, ranges from 0 to 30 minutes
			timeinminutessel=selectionpiece+1; // 0 is 1 min and onwards to 29 is 30 min
		else if (selectionpiece<60) // one piece is 5 minutes, ranges from 35 minutes to 180 minutes
			timeinminutessel=(30+(((selectionpiece-30)+1)*5)); // 30 is 35 min and onwards to 59 is 180 min
		else // so it's between 60 and 63 then, one piece is 30 minutes, ranges from 210 minutes to 300 minutes
			timeinminutessel=(180+(((selectionpiece-60)+1)*30)); // 60 is 210 min and onwards to 63 is 300 min
		// After timeminutessel is determined, we need to make it hours and minutes to be displayed on LCD screen
		// http://stackoverflow.com/questions/4228356/how-to-perform-integer-division-and-get-the-remainder-in-javascript
		// var remainder = x % y;
		// return (x - remainder) / y;
		minutessel=timeinminutessel % 60;
		// Conclusion: Use (a/b>>0) (or (~~(a/b)) or (a/b|0)) to achieve about 20% gain in efficiency. Also keep in mind
		// that they are all inconsistent with Math.floor, when a/b<0 && a%b!=0.
		hourssel=(((timeinminutessel-minutessel)/60)>>0); // division without remainder, floor
		} // accolade for oldselectionpiece if
	} // accolade for feedback if

}

/*Timer Counter 1 Compare Match A Interrupt Service Routine/Interrupt Handler*/
ISR(TIMER1_COMPA_vect)
{
	PORTC &= ~ (1<<0); //LED1 tic	
	_delay_ms(5);
	PORTC |= (1<<0); //LED1 tac	
	seconds++;

	if(seconds == 60)
	{
		seconds = 0;
		minutes++;
	}
	if(minutes == 60)
	{
		minutes = 0;
		hours++;		
	}
	if(hours > 23) {
		hours = 0;
	}

timeinminutes=60*hours+minutes;

if(timeinminutessel <= timeinminutes)
	{
	alarmmusic();
	}
}
